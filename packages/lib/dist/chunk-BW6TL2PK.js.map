{"version":3,"sources":["../src/collision/index.ts"],"names":["hitTestPoint","point","obj","global","bounds","centerX","centerY","Circle","left","right","top","bottom","Vector2D","Point","hitTestLine","l1","l2","x","y","hitTestLinePoint","p1","v1","v2","v3","hitTestLineCircle","c1","solid","slope","bounce","v0","pdp1","side","dp1","overlapX","overlapY","bounceOff","hitTestLineRectangle","r1","v1P","r1W","r1H","r1Wp","r1Hp","r1P","hDistance","dp","pos","hitTestCircle","c2","reactive","overlap","vec","combinedRadius","hasCollide","vxHalf","vyHalf","xSide","ySide","c1V","p1A","p1B","c2V","p2A","p2B","hitTestRectangle","r2","combinedHalfWidths","combinedHalfHeights","hitTestCircleRectangle","region","c1Pos","r1Pos","hitTestCircleTriangle","t1","hypotenuse","Line","boxCollision","hypotenuseSide","hypotenuseCollide","hitTestRectangleTriangle","surface","p2"],"mappings":"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","sourcesContent":["import { type DisplayObject } from \"DisplayObject\";\nimport { Vector2D, Point } from \"inks2d/math\";\nimport { Circle, type Rectangle, type Triangle, Line } from \"inks2d/geom\";\n\n/**\n * Checks for a collision against a Point and a DisplayObject\n *\n *\n * @param point A Point object.\n * @param obj A DisplayObject.\n * @param global If the function should use global coordinates. Default False\n *\n */\nexport const hitTestPoint = (\n\tpoint: Point,\n\tobj: DisplayObject,\n\tglobal: boolean = false,\n): { hasContact: boolean } => {\n\tlet bounds = obj.localBounds();\n\tlet centerX = obj.localCenterX;\n\tlet centerY = obj.localCenterY;\n\n\tif (global) {\n\t\tbounds = obj.globalBounds();\n\t\tcenterX = obj.globalCenterX;\n\t\tcenterY = obj.globalCenterY;\n\t}\n\n\tif (!(obj instanceof Circle)) {\n\t\t/*\n\t\tconst left = obj.position.x + bounds.x - bounds.width * obj.pivot.x;\n\t\tconst right = left + bounds.width;\n\t\tconst top = obj.position.y + bounds.y - bounds.height * obj.pivot.y;\n\t\tconst bottom = top + bounds.height;\n\t\t*/\n\n\t\tconst left = bounds.x - obj.width * obj.pivot.x;\n\t\tconst right = left + bounds.width;\n\t\tconst top = bounds.y - obj.height * obj.pivot.y;\n\t\tconst bottom = top + bounds.height;\n\n\t\treturn {\n\t\t\thasContact:\n\t\t\t\tpoint.x > left && point.x < right && point.y > top && point.y < bottom,\n\t\t};\n\t}\n\n\tif (obj instanceof Circle) {\n\t\tconst vec = new Vector2D(\n\t\t\tnew Point(centerX, centerY),\n\t\t\tnew Point(point.x, point.y),\n\t\t);\n\n\t\treturn { hasContact: vec.length < obj.radius };\n\t}\n\n\treturn { hasContact: false };\n};\n\n/**\n * Checks for a collision between two Lines.\n *\n *\n * @param l1 A Line object.\n * @param l2 A Line object.\n */\nexport const hitTestLine = (\n\tl1: Line,\n\tl2: Line,\n): { hasContact: boolean; overlap?: Point } => {\n\tconst x = (l2.yIntercepts - l1.yIntercepts) / (l1.slope - l2.slope);\n\tconst y = l1.slope * x + l1.yIntercepts;\n\tconst point = new Point(x, y);\n\n\tif (\n\t\thitTestLinePoint(l1, point).hasContact &&\n\t\thitTestLinePoint(l2, point).hasContact\n\t) {\n\t\treturn { hasContact: true, overlap: point };\n\t}\n\n\treturn { hasContact: false };\n};\n\n/**\n * Checks for a collision against a Line and a Point.\n *\n *\n * @param l1 A Line object.\n * @param p1 A Point object.\n */\nexport const hitTestLinePoint = (\n\tl1: Line,\n\tp1: Point,\n): { hasContact: boolean } => {\n\tconst v1 = new Vector2D(l1.a.clone(), l1.b.clone());\n\tconst v2 = new Vector2D(l1.a.clone(), p1.clone());\n\tconst v3 = new Vector2D(p1.clone(), l1.b.clone());\n\n\treturn { hasContact: v1.length > v2.length && v1.length > v3.length };\n};\n\n/**\n * Checks for a collision against a Line and a Circle.\n *\n *\n * @param l1 A Line object.\n * @param c1 A Circle object.\n * @param solid If the Line should be solid. Default False\n * @param slope If the Circle should slide across the Line. Default False\n * @param bounce If the Circle should bounce across the Line. Default False\n */\nexport const hitTestLineCircle = (\n\tl1: Line,\n\tc1: Circle,\n\tsolid: boolean = false,\n\tslope: boolean = false,\n\tbounce: boolean = false,\n): {\n\thasContact: boolean;\n\toverlap?: Point;\n\tside?: string;\n} => {\n\tconst v0 = new Vector2D(l1.a.clone(), l1.b.clone());\n\tconst v1 = new Vector2D(c1.position.clone(), l1.a.clone());\n\tconst v2 = new Vector2D(c1.position.clone(), new Point());\n\n\tconst pdp1 = Math.round(v1.perpDotProd(v0));\n\tlet side = \"\";\n\n\tif (pdp1 > 0) {\n\t\tside = \"left\";\n\t} else if (pdp1 < 0) {\n\t\tside = \"right\";\n\t}\n\n\tif (side === \"\" || side === \"left\") {\n\t\tv2.b.set(\n\t\t\tc1.position.x + v0.rightNormal.normalized.x * c1.radius,\n\t\t\tc1.position.y + v0.rightNormal.normalized.y * c1.radius,\n\t\t);\n\t} else {\n\t\tv2.b.set(\n\t\t\tc1.position.x + v0.leftNormal.normalized.x * c1.radius,\n\t\t\tc1.position.y + v0.leftNormal.normalized.y * c1.radius,\n\t\t);\n\t}\n\n\tconst v3 = new Vector2D(\n\t\tv2.b.clone(),\n\t\tnew Point(v2.b.x + c1.velocity.x, v2.b.y + c1.velocity.y),\n\t);\n\n\tconst v4 = new Vector2D(v3.a.clone(), v0.a.clone());\n\n\tconst dp1 = v4.dotProd(v0.leftNormal);\n\n\tif ((dp1 > 0 && side === \"left\") || (dp1 < 0 && side === \"right\")) {\n\t\tif (hitTestLinePoint(l1, v3.a.clone()).hasContact) {\n\t\t\tconst overlapX = v3.normalized.x * Math.abs(dp1);\n\t\t\tconst overlapY = v3.normalized.y * Math.abs(dp1);\n\n\t\t\tif (solid) {\n\t\t\t\tc1.position = c1.position.subtract(new Point(overlapX, overlapY));\n\t\t\t}\n\n\t\t\tif (slope) {\n\t\t\t\t/*\n\t\t\t\tlet frictionY = c1.friction.y;\n\n\t\t\t\tif (c1.velocity.y > 0) {\n\t\t\t\t\tfrictionY = 1.05;\n\t\t\t\t}\n\n\t\t\t\tlet bounceOff = this.bounceOff(c1, v0);\n\t\t\t\tbounceOff = bounceOff.multiply(frictionY);\n\t\t\t\t*/\n\t\t\t\t// console.log(bounceOff);\n\t\t\t\t// c1.position = c1.position.add(bounceOff);\n\t\t\t\tc1.position = c1.position.add(bounceOff(c1, v0));\n\t\t\t}\n\n\t\t\tif (slope) if (bounce) c1.velocity = bounceOff(c1, v0);\n\n\t\t\treturn {\n\t\t\t\thasContact: true,\n\t\t\t\toverlap: new Point(overlapX, overlapY),\n\t\t\t\tside,\n\t\t\t};\n\t\t}\n\t}\n\n\treturn { hasContact: false };\n};\n\n/**\n * Checks for a collision against a Line and a Rectangle.\n *\n * @param l1 A Line object.\n * @param r1 A Rectangle object.\n * @param solid If the Line should be solid. Default False\n * @param slope If the Rectangle should slide across the Line. Default False\n * @param bounce If the Rectangle should bounce across the Line. Default False\n */\nexport const hitTestLineRectangle = (\n\tl1: Line,\n\tr1: Rectangle,\n\tsolid: boolean = false,\n\tslope: boolean = false,\n\tbounce: boolean = false,\n): {\n\thasContact: boolean;\n\toverlap?: Point;\n\tside?: string;\n} => {\n\tconst v0 = new Vector2D(l1.a.clone(), l1.b.clone());\n\n\t/*\n\t * Create a distance vector between the center of the\n\t * rectangle and the center of the triangle;\n\t */\n\tconst v1 = new Vector2D(l1.a.clone(), r1.position);\n\n\tconst pdp1 = Math.round(v1.perpDotProd(v0));\n\tlet side = \"\";\n\n\tif (pdp1 > 0) {\n\t\tside = \"right\";\n\t} else if (pdp1 < 0) {\n\t\tside = \"left\";\n\t}\n\n\t/*\n\t * Project the distance vector onto the hypotenuse’s\n\t * normal;\n\t */\n\tconst v1P = v1.projection(v0.leftNormal);\n\n\t/*\n\t * Position the projection so that it starts at\n\t * point A of the hypotenuse’s left normal and\n\t * extends as far as the projection’s vx and vy;\n\t */\n\n\t/**\n\t * BEGIN: Rectangle Specific;\n\t */\n\t/*\n\t * Finds the square’s half height and half width\n\t * vectors;\n\t */\n\tconst r1W = new Vector2D(new Point(0, 0), new Point(r1.halfWidth, 0));\n\tconst r1H = new Vector2D(new Point(0, 0), new Point(0, r1.halfHeight));\n\n\t/*\n\t * Projects the square’s half height and\n\t * half width vectors onto the hypotenuse’s normal;\n\t */\n\tconst r1Wp = r1W.projection(v0.leftNormal);\n\tconst r1Hp = r1H.projection(v0.leftNormal);\n\tif (side === \"left\") r1Wp.reverse();\n\n\t/*\n\t * The distance between the square and the hypotenuse\n\t * is equal to the projection of the distance vector\n\t * minus the projection of the shape’s half width\n\t * and half height.\n\t */\n\tconst r1P = new Vector2D(\n\t\tnew Point(v0.leftNormal.a.x + v1P.vx, v0.leftNormal.a.y + v1P.vy),\n\t\tnew Point(\n\t\t\tv0.leftNormal.a.x + v1P.vx - (r1Wp.vx - r1Hp.vx),\n\t\t\tv0.leftNormal.a.y + v1P.vy - (r1Wp.vy - r1Hp.vy),\n\t\t),\n\t);\n\t/**\n\t * END: Rectangle Specific;\n\t */\n\n\t/*\n\t * Create a vector to represent the distance between\n\t * the square and the hypotenuse;\n\t */\n\tconst hDistance = new Vector2D(\n\t\tv0.leftNormal.a.clone(),\n\t\tnew Point(\n\t\t\tv0.leftNormal.a.x - v1P.vx - r1P.vx,\n\t\t\tv0.leftNormal.a.y - v1P.vy - r1P.vy,\n\t\t),\n\t);\n\n\t/*\n\t * Find the dot product between the hDistance and\n\t * the hypotenuse’s left normal. It will help us\n\t * to check whether the two shapes are overlapping;\n\t */\n\tconst dp = hDistance.dotProd(v0.leftNormal);\n\n\t/*\n\t * Check whether the projections are overlapping on\n\t * the x axis;\n\t */\n\tif ((dp > 0 && side === \"left\") || (dp < 0 && side === \"right\")) {\n\t\tconst pos = r1.position.add(new Point(hDistance.vx, hDistance.vy));\n\n\t\tif (hitTestLinePoint(l1, pos).hasContact) {\n\t\t\tif (solid)\n\t\t\t\tr1.position = r1.position.add(new Point(hDistance.vx, hDistance.vy));\n\n\t\t\tif (slope) r1.position = r1.position.add(bounceOff(r1, v0));\n\n\t\t\tif (bounce) r1.velocity = bounceOff(r1, v0);\n\n\t\t\treturn {\n\t\t\t\thasContact: true,\n\t\t\t\toverlap: new Point(hDistance.vx, hDistance.vy),\n\t\t\t\tside,\n\t\t\t};\n\t\t}\n\t}\n\n\treturn { hasContact: false };\n};\n\n/**\n * Checks for a collision between two Circles.\n *\n *\n * @param c1 A Circle object.\n * @param c2 A Circle object.\n * @param global If the function should use global coordinates. Default False\n * @param solid If the Objects should be solid. Default False\n * @param bounce If the Objects should bounce across each other. Default False\n * @param reactive If the Objects should be reactive across each other. Default False\n */\nexport const hitTestCircle = (\n\tc1: Circle,\n\tc2: Circle,\n\tglobal: boolean = false,\n\tsolid: boolean = false,\n\tbounce: boolean = false,\n\treactive: boolean = false,\n): {\n\thasContact: boolean;\n\toverlap?: number;\n} => {\n\tlet overlap;\n\n\tconst vec = new Vector2D(\n\t\tnew Point(c1.localCenterX, c1.localCenterY),\n\t\tnew Point(c2.localCenterX, c2.localCenterY),\n\t);\n\n\tconst combinedRadius = c1.bounds.width / 2 + c2.bounds.width / 2;\n\tconst hasCollide = vec.length < combinedRadius;\n\n\tif (global) {\n\t\tvec.a.x = c1.globalCenterX;\n\t\tvec.a.y = c1.globalCenterY;\n\t\tvec.b.x = c2.globalCenterX;\n\t\tvec.b.y = c2.globalCenterY;\n\t}\n\n\tif (solid && hasCollide) {\n\t\toverlap = combinedRadius - vec.length;\n\n\t\tif (!reactive) {\n\t\t\tc1.position.x -= overlap * vec.normalized.x;\n\t\t\tc1.position.y -= overlap * vec.normalized.y;\n\t\t} else {\n\t\t\tconst vxHalf = Math.abs((vec.normalized.x * overlap) / 2);\n\t\t\tconst vyHalf = Math.abs((vec.normalized.y * overlap) / 2);\n\n\t\t\tconst xSide = c1.position.x > c2.position.x ? 1 : -1;\n\t\t\tconst ySide = c1.position.y > c2.position.y ? 1 : -1;\n\n\t\t\tc1.position.x = c1.position.x + vxHalf * xSide;\n\t\t\tc1.position.y = c1.position.y + vyHalf * ySide;\n\n\t\t\tc2.position.x = c2.position.x + vxHalf * -xSide;\n\t\t\tc2.position.y = c2.position.y + vyHalf * -ySide;\n\t\t}\n\n\t\tif (bounce) {\n\t\t\tif (!reactive) {\n\t\t\t\tc1.velocity = bounceOff(c1, vec.leftNormal);\n\t\t\t} else {\n\t\t\t\tconst c1V = new Vector2D(c1.position, c1.position.add(c1.velocity));\n\t\t\t\tconst p1A = c1V.projection(vec);\n\t\t\t\tconst p1B = c1V.projection(vec.leftNormal);\n\n\t\t\t\tconst c2V = new Vector2D(c2.position, c2.position.add(c2.velocity));\n\t\t\t\tconst p2A = c2V.projection(vec);\n\t\t\t\tconst p2B = c2V.projection(vec.leftNormal);\n\n\t\t\t\tc1.velocity = new Point(\n\t\t\t\t\t(p1B.vx + p2A.vx) / c1.mass,\n\t\t\t\t\t(p1B.vy + p2A.vy) / c1.mass,\n\t\t\t\t);\n\n\t\t\t\tc2.velocity = new Point(\n\t\t\t\t\t(p1A.vx + p2B.vx) / c2.mass,\n\t\t\t\t\t(p1A.vy + p2B.vy) / c2.mass,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\thasContact: true,\n\t\t\toverlap,\n\t\t};\n\t}\n\n\treturn { hasContact: hasCollide };\n};\n\n/**\n * Checks for a collision between two Rectangles.\n *\n *\n * @param r1 A Rectangle object.\n * @param r2 A Rectangle object.\n * @param global If the function should use global coordinates. Default False\n * @param solid If the Objects should be solid. Default False\n * @param bounce If the Objects should bounce across each other. Default False\n * @param reactive If the Objects should be reactive across each other. Default False\n */\nexport const hitTestRectangle = (\n\tr1: Rectangle,\n\tr2: Rectangle,\n\tglobal: boolean = false,\n\tsolid: boolean = false,\n\tbounce: boolean = false,\n): {\n\thasContact: boolean;\n\toverlap?: Point;\n\tside?: string;\n} => {\n\tlet side: \"top\" | \"right\" | \"bottom\" | \"left\";\n\n\tconst vec = new Vector2D(\n\t\tnew Point(r2.localCenterX, r2.localCenterY),\n\t\tnew Point(r1.localCenterX, r1.localCenterY),\n\t);\n\n\tif (global) {\n\t\tvec.a.x = r2.globalCenterX;\n\t\tvec.a.y = r2.globalCenterY;\n\t\tvec.b.x = r1.globalCenterX;\n\t\tvec.b.y = r1.globalCenterY;\n\t}\n\n\tconst combinedHalfWidths = r1.bounds.width / 2 + r2.bounds.width / 2;\n\tconst combinedHalfHeights = r1.bounds.height / 2 + r2.bounds.height / 2;\n\n\tif (Math.abs(vec.vx) < combinedHalfWidths) {\n\t\tif (Math.abs(vec.vy) < combinedHalfHeights) {\n\t\t\tconst overlapX = combinedHalfWidths - Math.abs(vec.vx);\n\t\t\tconst overlapY = combinedHalfHeights - Math.abs(vec.vy);\n\n\t\t\tif (overlapX >= overlapY) {\n\t\t\t\tif (vec.vy > 0) {\n\t\t\t\t\tside = \"top\";\n\t\t\t\t\tif (solid) r1.position.y = r1.position.y + overlapY;\n\t\t\t\t} else {\n\t\t\t\t\tside = \"bottom\";\n\t\t\t\t\tif (solid) r1.position.y = r1.position.y - overlapY;\n\t\t\t\t}\n\n\t\t\t\tif (solid && bounce) {\n\t\t\t\t\tr1.velocity.y *= -1;\n\t\t\t\t\tbounceOff(r1, vec.leftNormal);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (vec.vx > 0) {\n\t\t\t\t\tside = \"left\";\n\t\t\t\t\tif (solid) r1.position.x = r1.position.x + overlapX;\n\t\t\t\t} else {\n\t\t\t\t\tside = \"right\";\n\t\t\t\t\tif (solid) r1.position.x = r1.position.x - overlapX;\n\t\t\t\t}\n\n\t\t\t\tif (solid && bounce) {\n\t\t\t\t\tr1.velocity.x *= -1;\n\t\t\t\t\tbounceOff(r1, vec.leftNormal);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\thasContact: true,\n\t\t\t\toverlap: new Point(overlapX, overlapY),\n\t\t\t\tside,\n\t\t\t};\n\t\t}\n\t}\n\n\treturn { hasContact: false };\n};\n\n/**\n * Checks for a collision between a Circle and a Rectangle.\n *\n * @param c1 A Circle object.\n * @param r1 A Rectangle object.\n * @param global If the function should use global coordinates. Default False\n * @param solid If the Objects should be solid. Default False\n * @param bounce If the Objects should bounce across each other. Default False\n */\nexport const hitTestCircleRectangle = (\n\tc1: Circle,\n\tr1: Rectangle,\n\tglobal: boolean = false,\n\tsolid: boolean = false,\n\tbounce: boolean = false,\n): {\n\thasContact: boolean;\n\toverlap?: Point | number;\n\tside?: string;\n} => {\n\tlet region;\n\n\tconst c1Pos = new Point(c1.position.x, c1.position.y);\n\tconst r1Pos = new Point(r1.localCenterX, r1.localCenterY);\n\n\tif (c1Pos.y < r1Pos.y - r1.halfHeight) {\n\t\tif (c1Pos.x < r1Pos.x - 1 - r1.halfWidth) {\n\t\t\tregion = \"topLeft\";\n\t\t} else if (c1Pos.x > r1Pos.x + 1 + r1.halfWidth) {\n\t\t\tregion = \"topRight\";\n\t\t} else {\n\t\t\tregion = \"topMiddle\";\n\t\t}\n\t} else if (c1Pos.y > r1Pos.y + r1.halfHeight) {\n\t\tif (c1Pos.x < r1Pos.x - 1 - r1.halfWidth) {\n\t\t\tregion = \"bottomLeft\";\n\t\t} else if (c1Pos.x > r1Pos.x + 1 + r1.halfWidth) {\n\t\t\tregion = \"bottomRight\";\n\t\t} else {\n\t\t\tregion = \"bottomMiddle\";\n\t\t}\n\t} else {\n\t\tif (c1Pos.x < r1Pos.x - r1.halfWidth) {\n\t\t\tregion = \"leftMiddle\";\n\t\t} else {\n\t\t\tregion = \"rightMiddle\";\n\t\t}\n\t}\n\n\tif (\n\t\tregion === \"topMiddle\" ||\n\t\tregion === \"bottomMiddle\" ||\n\t\tregion === \"leftMiddle\" ||\n\t\tregion === \"rightMiddle\"\n\t) {\n\t\treturn hitTestRectangle(c1, r1, global, solid, bounce);\n\t}\n\n\tconst point = new Circle(0.1, 0.1);\n\n\tswitch (region) {\n\t\tcase \"topLeft\":\n\t\t\tpoint.position.x = r1.position.x - r1.width * r1.pivot.x;\n\t\t\tpoint.position.y = r1.position.y - r1.height * r1.pivot.y;\n\t\t\tbreak;\n\t\tcase \"topRight\":\n\t\t\tpoint.position.x = r1.position.x - r1.width * r1.pivot.x + r1.width;\n\t\t\tpoint.position.y = r1.position.y - r1.height * r1.pivot.y;\n\t\t\tbreak;\n\t\tcase \"bottomLeft\":\n\t\t\tpoint.position.x = r1.position.x - r1.width * r1.pivot.x;\n\t\t\tpoint.position.y = r1.position.y - r1.height * r1.pivot.y + r1.height;\n\t\t\tbreak;\n\t\tcase \"bottomRight\":\n\t\t\tpoint.position.x = r1.position.x - r1.width * r1.pivot.x + r1.width;\n\t\t\tpoint.position.y = r1.position.y - r1.height * r1.pivot.y + r1.height;\n\t\t\tbreak;\n\t}\n\n\treturn hitTestCircle(c1, point, false, solid, bounce, false);\n};\n\n/**\n * Checks for a collision between a Circle and a Triangle.\n *\n * @param c1 A Circle object.\n * @param t1 A Triangle object.\n * @param solid If the Objects should be solid. Default False\n * @param slope If the Circle should slide across the Triangle hypotenuse. Default False\n * @param bounce If the Circle should bounce across the Triangle hypotenuse. Default False\n */\nexport const hitTestCircleTriangle = (\n\tc1: Circle,\n\tt1: Triangle,\n\tsolid: boolean = false,\n\tslope: boolean = false,\n\tbounce: boolean = false,\n): {\n\thasContact: boolean;\n\toverlap?: Point | number;\n\tside?: string;\n} => {\n\tconst hypotenuse = new Line(t1.hypotenuse.a.clone(), t1.hypotenuse.b.clone());\n\n\tconst boxCollision = hitTestCircleRectangle(c1, t1, false, false, false);\n\n\tif (boxCollision.hasContact) {\n\t\tconst { side } = boxCollision;\n\n\t\tconst v0 = new Vector2D(\n\t\t\tnew Point(c1.localCenterX, c1.localCenterY),\n\t\t\thypotenuse.a.clone(),\n\t\t);\n\n\t\tconst hypotenuseSide = t1.hypotenuse.perpDotProd(v0);\n\n\t\tif (t1.inclination === \"right\") {\n\t\t\tif (side === \"right\" || (side === \"top\" && hypotenuseSide > 0)) {\n\t\t\t\treturn hitTestCircleRectangle(c1, t1, false, solid, bounce);\n\t\t\t}\n\n\t\t\tconst hypotenuseCollide = hitTestLineCircle(\n\t\t\t\thypotenuse,\n\t\t\t\tc1,\n\t\t\t\tsolid,\n\t\t\t\tslope,\n\t\t\t\tbounce,\n\t\t\t);\n\n\t\t\tif (hypotenuseCollide.hasContact)\n\t\t\t\treturn { ...hypotenuseCollide, side: \"hypotenuse\" };\n\n\t\t\treturn hypotenuseCollide;\n\t\t}\n\n\t\tif (side === \"left\" || (side === \"top\" && hypotenuseSide > 0)) {\n\t\t\treturn hitTestCircleRectangle(c1, t1, false, solid, bounce);\n\t\t}\n\n\t\tconst hypotenuseCollide = hitTestLineCircle(\n\t\t\thypotenuse,\n\t\t\tc1,\n\t\t\tsolid,\n\t\t\tslope,\n\t\t\tbounce,\n\t\t);\n\n\t\tif (hypotenuseCollide.hasContact)\n\t\t\treturn { ...hypotenuseCollide, side: \"hypotenuse\" };\n\n\t\treturn hypotenuseCollide;\n\t}\n\n\treturn boxCollision;\n};\n\n/**\n * Checks for a collision between a Circle and a Triangle.\n *\n * @param c1 A Circle object.\n * @param t1 A Triangle object.\n * @param solid If the Objects should be solid. Default False\n * @param slope If the Circle should slide across the Triangle hypotenuse. Default False\n * @param bounce If the Circle should bounce across the Triangle hypotenuse. Default False\n */\nexport const hitTestRectangleTriangle = (\n\tr1: Rectangle,\n\tt1: Triangle,\n\tsolid: boolean = false,\n\tslope: boolean = false,\n\tbounce: boolean = false,\n): { hasContact: boolean } => {\n\tconst boxCollision = hitTestRectangle(r1, t1, false, false, false);\n\n\tif (boxCollision.hasContact) {\n\t\tconst { side } = boxCollision;\n\t\tlet hypotenuse = new Line(t1.hypotenuse.b.clone(), t1.hypotenuse.a.clone());\n\n\t\tif (t1.inclination === \"right\") {\n\t\t\tif (side === \"right\" || side === \"top\") {\n\t\t\t\treturn hitTestRectangle(r1, t1, false, solid, bounce);\n\t\t\t}\n\n\t\t\treturn hitTestLineRectangle(hypotenuse, r1, solid, slope, bounce);\n\t\t}\n\n\t\thypotenuse = new Line(t1.hypotenuse.a.clone(), t1.hypotenuse.b.clone());\n\n\t\tif (side === \"left\" || side === \"top\") {\n\t\t\treturn hitTestRectangle(r1, t1, false, solid, bounce);\n\t\t}\n\n\t\treturn hitTestLineRectangle(hypotenuse, r1, solid, slope, bounce);\n\t}\n\n\treturn boxCollision;\n};\n\nconst bounceOff = (obj: DisplayObject, surface: Vector2D): Point => {\n\tconst pos = new Vector2D(\n\t\tobj.position.clone(),\n\t\tobj.position.add(obj.velocity),\n\t);\n\n\tconst p1 = pos.projection(surface);\n\tconst p2 = pos.projection(surface.leftNormal);\n\tp2.reverse();\n\n\treturn new Point((p1.vx + p2.vx) / obj.mass, (p1.vy + p2.vy) / obj.mass);\n};\n"]}