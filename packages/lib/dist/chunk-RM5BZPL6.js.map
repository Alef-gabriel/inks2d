{"version":3,"sources":["../src/utils/index.ts","../src/tiles/Map.ts","../src/tiles/MapCamera.ts","../src/tiles/index.ts"],"names":["Detect","wait","duration","resolve","shake","sprite","numberOfShakes","magnitude","angular","counter","startX","startY","startAngle","tiltAngle","magnitudeUnit","EC_SHAKING_SPRITES","angularShake","upAndDownShake","randomInt","makeInteractive","buttonProps","isInstanceOfSprite","Sprite","pointer","cursors","cIds","i","cursor","hit","hitTestPoint","Point","EC_BUTTONS","remove","spritesToRemove","frame","source","x","y","width","height","frames","arrOfPositions","contain","bounds","bounce","callback","side","getSpatialGrid","spritesArray","columns","rows","cellWidth","cellHeight","length","gridArray","index","getIndex","move","sprites","s","miliToTimer","mili","includeHour","removeSpace","h","m","txtHour","txtMinute","txtSeconds","timer","Map","Group","jsonTiledMap","tileset","numberOfTilesetColumns","tiledLayer","layerGroup","gid","tilesetX","tilesetY","mapColumn","mapRow","mapX","mapY","tilesetColumn","tilesetRow","texture","tileProperties","key","tileSprite","property","object","objectName","obj","mapArray","spritesToUpdate","newMapArray","gidToCheck","pointsToCheck","collision","collisionPoints","getPoints","checkPoints","point","methodToExec","MapCamera","map","canvas","value","pos","tileWidth","tileHeight","mapWidthInTiles","global","hitTestTile"],"mappings":"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","sourcesContent":["import { type DisplayObject } from \"DisplayObject\";\r\nimport { type Pointer } from \"../inputs/Pointer\";\r\nimport { EC_BUTTONS, EC_SHAKING_SPRITES } from \"EngineConstants\";\r\nimport { Sprite } from \"inks2d/graphics\";\r\nimport { hitTestPoint } from \"inks2d/collision\";\r\nimport { Point, randomInt } from \"inks2d/math\";\r\nimport { getIndex } from \"inks2d/tiles\";\r\n\r\nexport const Detect = {\r\n\tAndroid: () => !(navigator.userAgent.match(/Android/i) == null),\r\n\tiOS: () => !(navigator.userAgent.match(/iPhone|iPad|iPod/i) == null),\r\n};\r\n\r\nexport const wait = async (\r\n\tduration: number = 0,\r\n): Promise<PromiseConstructor> => {\r\n\treturn await new Promise(function (resolve) {\r\n\t\tsetTimeout(resolve, duration);\r\n\t});\r\n};\r\n\r\nexport const shake = (\r\n\tsprite: DisplayObject,\r\n\tnumberOfShakes: number = 10,\r\n\tmagnitude: number = 16,\r\n\tangular: boolean = false,\r\n): void => {\r\n\tlet counter = 1;\r\n\tconst startX = sprite.position.x;\r\n\tconst startY = sprite.position.y;\r\n\tconst startAngle = sprite.rotation;\r\n\tlet tiltAngle = 1;\r\n\r\n\tconst magnitudeUnit = magnitude / numberOfShakes;\r\n\r\n\tif (!EC_SHAKING_SPRITES.includes(sprite)) {\r\n\t\tEC_SHAKING_SPRITES.push(sprite);\r\n\r\n\t\tsprite.customProperties._____updateShake = function () {\r\n\t\t\tif (angular) {\r\n\t\t\t\tangularShake();\r\n\t\t\t} else {\r\n\t\t\t\tupAndDownShake();\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\tfunction upAndDownShake(): void {\r\n\t\tif (counter < numberOfShakes) {\r\n\t\t\tsprite.position.x = startX;\r\n\t\t\tsprite.position.y = startY;\r\n\r\n\t\t\tmagnitude -= magnitudeUnit;\r\n\r\n\t\t\tsprite.position.x += randomInt(-magnitude, magnitude);\r\n\t\t\tsprite.position.y += randomInt(-magnitude, magnitude);\r\n\r\n\t\t\tcounter++;\r\n\t\t}\r\n\r\n\t\tif (counter >= numberOfShakes) {\r\n\t\t\tsprite.position.x = startX;\r\n\t\t\tsprite.position.y = startY;\r\n\t\t\tEC_SHAKING_SPRITES.splice(EC_SHAKING_SPRITES.indexOf(sprite), 1);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction angularShake(): void {\r\n\t\tif (counter < numberOfShakes) {\r\n\t\t\tsprite.rotation = startAngle;\r\n\t\t\tmagnitude -= magnitudeUnit;\r\n\t\t\tsprite.rotation = magnitude * tiltAngle;\r\n\t\t\tcounter++;\r\n\t\t\ttiltAngle *= -1;\r\n\t\t}\r\n\r\n\t\tif (counter >= numberOfShakes) {\r\n\t\t\tsprite.rotation = startAngle;\r\n\t\t\tEC_SHAKING_SPRITES.splice(EC_SHAKING_SPRITES.indexOf(sprite), 1);\r\n\t\t}\r\n\t}\r\n};\r\n\r\nexport const makeInteractive = (sprite: DisplayObject): void => {\r\n\tsprite.customProperties.buttonProps = {};\r\n\tconst { buttonProps } = sprite.customProperties;\r\n\tconst isInstanceOfSprite = sprite instanceof Sprite;\r\n\r\n\tbuttonProps.enabled = true;\r\n\tbuttonProps.state = \"up\";\r\n\tbuttonProps.action = \"\";\r\n\tbuttonProps.pressed = false;\r\n\tbuttonProps.hoverOver = false;\r\n\tbuttonProps._pointerId = undefined;\r\n\tbuttonProps._____updateButton = (pointer: Pointer) => {\r\n\t\tconst cursors = pointer.cursors;\r\n\t\tconst cIds = Array.from(cursors.keys());\r\n\r\n\t\tif (!sprite.visible || !buttonProps.enabled) {\r\n\t\t\tbuttonProps.state = \"up\";\r\n\t\t\tbuttonProps.action = \"\";\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfor (let i = cIds.length - 1; i >= 0; i--) {\r\n\t\t\tconst cursor = cursors.get(cIds[i]);\r\n\r\n\t\t\tif (!cursor) continue;\r\n\r\n\t\t\tconst hit = hitTestPoint(new Point(cursor.x, cursor.y), sprite, true);\r\n\r\n\t\t\tif (cursor.isUp) {\r\n\t\t\t\tif (buttonProps._pointerId === cIds[i] || cIds.length === 1) {\r\n\t\t\t\t\tbuttonProps.state = \"up\";\r\n\t\t\t\t\tisInstanceOfSprite && sprite.gotoAndStop(0);\r\n\t\t\t\t\tbuttonProps._pointerId = undefined;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (hit.hasContact) {\r\n\t\t\t\tbuttonProps.state = \"over\";\r\n\r\n\t\t\t\tif (isInstanceOfSprite && sprite.frames && sprite.frames.length === 3) {\r\n\t\t\t\t\tsprite.gotoAndStop(1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (cursor.isDown) {\r\n\t\t\t\t\tbuttonProps.state = \"down\";\r\n\t\t\t\t\tbuttonProps._pointerId = cIds[i];\r\n\r\n\t\t\t\t\tisInstanceOfSprite && sprite.gotoAndStop(1);\r\n\r\n\t\t\t\t\tif (isInstanceOfSprite && sprite.frames.length === 3) {\r\n\t\t\t\t\t\tsprite.gotoAndStop(2);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (buttonProps._pointerId === cIds[i] || cIds.length === 1) {\r\n\t\t\t\t\tbuttonProps.state = \"up\";\r\n\t\t\t\t\tbuttonProps.pressed = false;\r\n\r\n\t\t\t\t\tisInstanceOfSprite && sprite.gotoAndStop(0);\r\n\r\n\t\t\t\t\tbuttonProps._pointerId = undefined;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (buttonProps.state === \"down\") {\r\n\t\t\t\tif (!buttonProps.pressed) {\r\n\t\t\t\t\tif (buttonProps.press) buttonProps.press(this);\r\n\r\n\t\t\t\t\tbuttonProps.pressed = true;\r\n\t\t\t\t\tbuttonProps.action = \"pressed\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (buttonProps.state === \"over\") {\r\n\t\t\t\tif (buttonProps.pressed) {\r\n\t\t\t\t\tif (buttonProps.release) buttonProps.release(sprite);\r\n\r\n\t\t\t\t\tbuttonProps.pressed = false;\r\n\t\t\t\t\tbuttonProps.action = \"released\";\r\n\r\n\t\t\t\t\tif (cursor.tapped && buttonProps.tap) buttonProps.tap(sprite);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!buttonProps.hoverOver) {\r\n\t\t\t\t\tif (buttonProps.over) buttonProps.over(sprite);\r\n\r\n\t\t\t\t\tbuttonProps.hoverOver = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (buttonProps.state === \"up\") {\r\n\t\t\t\tif (buttonProps.pressed) {\r\n\t\t\t\t\tif (buttonProps.release) buttonProps.release(sprite);\r\n\r\n\t\t\t\t\tbuttonProps.pressed = false;\r\n\t\t\t\t\tbuttonProps.action = \"released\";\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (buttonProps.hoverOver) {\r\n\t\t\t\t\tif (buttonProps.out) buttonProps.out(sprite);\r\n\r\n\t\t\t\t\tbuttonProps.hoverOver = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tEC_BUTTONS.push(sprite);\r\n};\r\n\r\nexport const remove = (...spritesToRemove: DisplayObject[]): void => {\r\n\tspritesToRemove.forEach((sprite) => {\r\n\t\tif (sprite.parent != null) sprite.parent.removeChild(sprite);\r\n\t});\r\n};\r\n\r\nexport const frame = (\r\n\tsource: HTMLImageElement,\r\n\tx: number,\r\n\ty: number,\r\n\twidth: number,\r\n\theight: number,\r\n): {\r\n\timage: HTMLImageElement;\r\n\tx: number;\r\n\ty: number;\r\n\twidth: number;\r\n\theight: number;\r\n} => {\r\n\treturn {\r\n\t\timage: source,\r\n\t\tx,\r\n\t\ty,\r\n\t\twidth,\r\n\t\theight,\r\n\t};\r\n};\r\n\r\nexport const frames = (\r\n\tsource: HTMLImageElement,\r\n\tarrOfPositions: number[],\r\n\twidth: number,\r\n\theight: number,\r\n): {\r\n\timage: HTMLImageElement;\r\n\tdata: number[];\r\n\twidth: number;\r\n\theight: number;\r\n} => {\r\n\treturn {\r\n\t\timage: source,\r\n\t\tdata: arrOfPositions,\r\n\t\twidth,\r\n\t\theight,\r\n\t};\r\n};\r\n\r\nexport const contain = (\r\n\tsprite: DisplayObject,\r\n\tbounds: { x: number; y: number; width: number; height: number },\r\n\tbounce: boolean = false,\r\n\tcallback?: (side: string) => void,\r\n): string | undefined => {\r\n\tconst x = bounds.x;\r\n\tconst y = bounds.y;\r\n\tconst width = bounds.width;\r\n\tconst height = bounds.height;\r\n\tlet side;\r\n\r\n\tif (sprite.position.x < x) {\r\n\t\tif (bounce) sprite.velocity.x *= -1;\r\n\r\n\t\tif (sprite.mass) sprite.velocity.x /= sprite.mass;\r\n\r\n\t\tsprite.position.x = x;\r\n\t\tside = \"left\";\r\n\t}\r\n\r\n\tif (sprite.position.y < y) {\r\n\t\tif (bounce) sprite.velocity.y *= -1;\r\n\r\n\t\tif (sprite.mass) sprite.velocity.y /= sprite.mass;\r\n\r\n\t\tsprite.position.y = y;\r\n\t\tside = \"top\";\r\n\t}\r\n\r\n\tif (sprite.position.x > width) {\r\n\t\tif (bounce) sprite.velocity.x *= -1;\r\n\r\n\t\tif (sprite.mass) sprite.velocity.x /= sprite.mass;\r\n\r\n\t\tsprite.position.x = width;\r\n\t\tside = \"right\";\r\n\t}\r\n\r\n\tif (sprite.position.y > height) {\r\n\t\tif (bounce) sprite.velocity.y *= -1;\r\n\r\n\t\tif (sprite.mass) sprite.velocity.y /= sprite.mass;\r\n\r\n\t\tsprite.position.y = height;\r\n\t\tside = \"bottom\";\r\n\t}\r\n\r\n\tif (side && callback) callback(side);\r\n\r\n\treturn side;\r\n};\r\n\r\nexport const getSpatialGrid = (\r\n\tspritesArray: DisplayObject[],\r\n\tcolumns: number = 0,\r\n\trows: number = 0,\r\n\tcellWidth: number = 32,\r\n\tcellHeight: number = 32,\r\n): any[] => {\r\n\tconst length = columns * rows;\r\n\tconst gridArray: any[] = [];\r\n\r\n\tfor (let i = 0; i < length; i++) {\r\n\t\tgridArray.push([]);\r\n\t}\r\n\r\n\tspritesArray.forEach((sprite) => {\r\n\t\tconst index = getIndex(\r\n\t\t\tsprite.position.clone(),\r\n\t\t\tcellWidth,\r\n\t\t\tcellHeight,\r\n\t\t\tcolumns,\r\n\t\t);\r\n\r\n\t\tgridArray[index].push(sprite);\r\n\t});\r\n\r\n\treturn gridArray;\r\n};\r\n\r\nexport const move = (...sprites: DisplayObject[]): void => {\r\n\tsprites.forEach((s) => {\r\n\t\ts.position = s.position.add(s.velocity);\r\n\t});\r\n};\r\n\r\nexport const miliToTimer = (\r\n\tmili: number,\r\n\tincludeHour: boolean = false,\r\n\tremoveSpace: boolean = false,\r\n): string => {\r\n\tlet h, s;\r\n\ts = mili / 1000;\r\n\r\n\tif (includeHour) {\r\n\t\th = Math.floor(s / 3600);\r\n\t\ts = s % 3600;\r\n\t}\r\n\r\n\tconst m = Math.floor(s / 60);\r\n\ts = Math.floor(s % 60);\r\n\r\n\tlet txtHour = \"\";\r\n\tif (h) txtHour = h >= 10 ? `${h}` : h > 0 ? `0${h}` : \"00\";\r\n\tconst txtMinute = m >= 10 ? m : m > 0 ? `0${m}` : \"00\";\r\n\tconst txtSeconds = s >= 10 ? s : s > 0 ? `0${s}` : \"00\";\r\n\r\n\tlet timer = includeHour ? `${txtHour?.toString()} : ` : \"\";\r\n\ttimer += `${txtMinute} : ${txtSeconds}`;\r\n\r\n\tif (removeSpace) timer = timer.split(\" \").join(\"\");\r\n\r\n\treturn timer;\r\n};\r\n","import { type DisplayObject } from \"DisplayObject\";\nimport { Sprite } from \"inks2d/graphics\";\nimport { Point } from \"inks2d/math\";\nimport { Group } from \"inks2d/group\";\nimport { frame } from \"inks2d/utils\";\nimport { getIndex, getPoints } from \"inks2d/tiles\";\n\nexport class Map extends Group {\n\tprivate readonly _tiledMap: Record<string, any>;\n\tprivate readonly _tileset: HTMLImageElement;\n\tprivate readonly _tileWidth: number;\n\tprivate readonly _tileHeight: number;\n\tprivate readonly _mapWidth: number;\n\tprivate readonly _mapHeight: number;\n\tprivate readonly _mapWidthInTiles: number;\n\tprivate readonly _mapHeightInTiles: number;\n\tprivate readonly _spacing: number;\n\tprivate readonly _objects: any[] = [];\n\n\tconstructor(jsonTiledMap: Record<string, any>, tileset: HTMLImageElement) {\n\t\tsuper();\n\n\t\tthis._tiledMap = jsonTiledMap;\n\t\tthis._tileset = tileset;\n\t\tthis._tileWidth = this._tiledMap.tilewidth;\n\t\tthis._tileHeight = this._tiledMap.tileheight;\n\t\tthis._mapWidth = this._tiledMap.width * this._tiledMap.tilewidth;\n\t\tthis._mapHeight = this._tiledMap.height * this._tiledMap.tileheight;\n\t\tthis._mapWidthInTiles = this._tiledMap.width;\n\t\tthis._mapHeightInTiles = this._tiledMap.height;\n\t\tthis._spacing = this._tiledMap.tilesets[0].spacing;\n\n\t\tconst numberOfTilesetColumns = Math.floor(\n\t\t\tthis._tiledMap.tilesets[0].imagewidth / this._tiledMap.tilewidth +\n\t\t\t\tthis._spacing,\n\t\t);\n\n\t\tthis._tiledMap.layers.forEach((tiledLayer: Record<string, any>) => {\n\t\t\tconst layerGroup = new Group();\n\t\t\tlayerGroup.alpha = tiledLayer.opacity;\n\t\t\tlayerGroup.visible = tiledLayer.visible;\n\t\t\tlayerGroup.customProperties.name = tiledLayer.name;\n\t\t\tlayerGroup.customProperties.data = tiledLayer.data;\n\t\t\tlayerGroup.position.set(tiledLayer.x, tiledLayer.y);\n\t\t\tlayerGroup.renderOutside = true;\n\n\t\t\tthis._objects.push(layerGroup);\n\t\t\tthis.addChild(layerGroup);\n\n\t\t\tif (tiledLayer.type === \"tilelayer\") {\n\t\t\t\ttiledLayer.data.forEach((gid: number, index: number) => {\n\t\t\t\t\tif (gid === 0) return;\n\n\t\t\t\t\tlet tilesetX, tilesetY;\n\n\t\t\t\t\tconst mapColumn = index % this._mapWidthInTiles;\n\t\t\t\t\tconst mapRow = Math.floor(index / this._mapWidthInTiles);\n\t\t\t\t\tconst mapX = mapColumn * this._tileWidth;\n\t\t\t\t\tconst mapY = mapRow * this._tileHeight;\n\n\t\t\t\t\tconst tilesetColumn = (gid - 1) % numberOfTilesetColumns;\n\t\t\t\t\tconst tilesetRow = Math.floor((gid - 1) / numberOfTilesetColumns);\n\t\t\t\t\ttilesetX = tilesetColumn * this._tileWidth;\n\t\t\t\t\ttilesetY = tilesetRow * this._tileHeight;\n\n\t\t\t\t\tif (this._spacing > 0) {\n\t\t\t\t\t\ttilesetX +=\n\t\t\t\t\t\t\tthis._spacing +\n\t\t\t\t\t\t\tthis._spacing * ((gid - 1) % numberOfTilesetColumns);\n\t\t\t\t\t\ttilesetY +=\n\t\t\t\t\t\t\tthis._spacing +\n\t\t\t\t\t\t\tthis._spacing * Math.floor((gid - 1) / numberOfTilesetColumns);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst texture = frame(\n\t\t\t\t\t\tthis._tileset,\n\t\t\t\t\t\ttilesetX,\n\t\t\t\t\t\ttilesetY,\n\t\t\t\t\t\tthis._tileWidth,\n\t\t\t\t\t\tthis._tileHeight,\n\t\t\t\t\t);\n\n\t\t\t\t\tconst tileProperties = this._tiledMap.tilesets[0].tileproperties;\n\t\t\t\t\tconst key = String(gid - 1);\n\t\t\t\t\tconst tileSprite = new Sprite(texture);\n\n\t\t\t\t\tif (tileProperties[key].name) {\n\t\t\t\t\t\tObject.keys(tileProperties[key]).forEach((property: string) => {\n\t\t\t\t\t\t\ttileSprite.customProperties[property] =\n\t\t\t\t\t\t\t\ttileProperties[key][property];\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tthis._objects.push(tileSprite);\n\t\t\t\t\t}\n\n\t\t\t\t\ttileSprite.position.set(mapX, mapY);\n\t\t\t\t\ttileSprite.pivot.set(0, 0);\n\t\t\t\t\ttileSprite.customProperties.index = index;\n\t\t\t\t\ttileSprite.customProperties.gid = gid;\n\n\t\t\t\t\tlayerGroup.addChild(tileSprite);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (tiledLayer.type === \"objectgroup\") {\n\t\t\t\ttiledLayer.objects.forEach((object: Record<string, any>) => {\n\t\t\t\t\tobject.group = layerGroup;\n\t\t\t\t\tthis._objects.push(object);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\tget mapWidth(): number {\n\t\treturn this._mapWidth;\n\t}\n\n\tget mapHeight(): number {\n\t\treturn this._mapHeight;\n\t}\n\n\tget mapWidthInTiles(): number {\n\t\treturn this._mapWidthInTiles;\n\t}\n\n\tget mapHeightInTiles(): number {\n\t\treturn this._mapHeightInTiles;\n\t}\n\n\tget tileWidth(): number {\n\t\treturn this._tileWidth;\n\t}\n\n\tget tileHeight(): number {\n\t\treturn this._tileHeight;\n\t}\n\n\tgetObject(objectName: string): any {\n\t\tconst object = this._objects.find((obj) => {\n\t\t\treturn (\n\t\t\t\t(obj.name && obj.name === objectName) ||\n\t\t\t\t(obj.customProperties.name && obj.customProperties.name === objectName)\n\t\t\t);\n\t\t});\n\n\t\tif (object) return object;\n\n\t\tthrow new Error(`There is no object with the property name: ${objectName}`);\n\t}\n\n\tgetObjects(objectName: string): any[] {\n\t\tconst object = this._objects.filter((obj) => {\n\t\t\treturn (\n\t\t\t\t(obj.name && obj.name === objectName) ||\n\t\t\t\t(obj.customProperties.name && obj.customProperties.name === objectName)\n\t\t\t);\n\t\t});\n\n\t\tif (object) return object;\n\n\t\tthrow new Error(`There is no object with the property name: ${objectName}`);\n\t}\n\n\tupdateMap(\n\t\tmapArray: number[],\n\t\tspritesToUpdate: DisplayObject | DisplayObject[],\n\t): number[] {\n\t\tconst newMapArray = mapArray.map((gid) => {\n\t\t\tgid = 0;\n\t\t\treturn gid;\n\t\t});\n\n\t\tif (spritesToUpdate instanceof Array) {\n\t\t\tspritesToUpdate.forEach((sprite) => {\n\t\t\t\tsprite.customProperties.index = getIndex(\n\t\t\t\t\tnew Point(sprite.localCenterX, sprite.localCenterY),\n\t\t\t\t\tthis.tileWidth,\n\t\t\t\t\tthis.tileHeight,\n\t\t\t\t\tthis.mapWidthInTiles,\n\t\t\t\t);\n\n\t\t\t\tnewMapArray[sprite.customProperties.index] =\n\t\t\t\t\tsprite.customProperties.gid;\n\t\t\t});\n\n\t\t\treturn newMapArray;\n\t\t}\n\n\t\tconst sprite = spritesToUpdate;\n\n\t\tsprite.customProperties.index = getIndex(\n\t\t\tnew Point(sprite.localCenterX, sprite.localCenterY),\n\t\t\tthis.tileWidth,\n\t\t\tthis.tileHeight,\n\t\t\tthis.mapWidthInTiles,\n\t\t);\n\n\t\tnewMapArray[sprite.customProperties.index] = sprite.customProperties.gid;\n\n\t\treturn newMapArray;\n\t}\n\n\thitTestTile(\n\t\tsprite: DisplayObject,\n\t\tmapArray: number[],\n\t\tgidToCheck: number,\n\t\tpointsToCheck: \"every\" | \"some\" | \"center\" = \"some\",\n\t): Record<string, number | boolean> {\n\t\tconst collision: Record<string, number | boolean> = {};\n\t\tlet collisionPoints: Record<string, Point> = getPoints(sprite);\n\n\t\tconst checkPoints = (key: string): boolean => {\n\t\t\tconst point = collisionPoints[key];\n\t\t\tcollision.index = getIndex(\n\t\t\t\tpoint,\n\t\t\t\tthis.tileWidth,\n\t\t\t\tthis.tileHeight,\n\t\t\t\tthis.mapWidthInTiles,\n\t\t\t);\n\n\t\t\tcollision.gid = mapArray[collision.index];\n\n\t\t\tif (collision.gid === gidToCheck) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t};\n\n\t\tconst methodToExec = pointsToCheck === \"center\" ? \"some\" : pointsToCheck;\n\n\t\tif (pointsToCheck === \"center\") {\n\t\t\tconst point = {\n\t\t\t\tcenter: new Point(sprite.localCenterX, sprite.localCenterY),\n\t\t\t};\n\t\t\tcollisionPoints = point;\n\t\t}\n\n\t\tcollision.hasContact =\n\t\t\tObject.keys(collisionPoints)[methodToExec](checkPoints);\n\n\t\treturn collision;\n\t}\n}\n","import { type DisplayObject } from \"DisplayObject\";\nimport { Point } from \"inks2d/math\";\nimport { type Map } from \"./Map\";\n\nexport class MapCamera {\n\tpublic scale: Point = new Point();\n\tpublic width: number = 0;\n\tpublic height: number = 0;\n\n\tprivate readonly _map: Map;\n\tprivate _x: number = 0;\n\tprivate _y: number = 0;\n\n\tconstructor(map: Map, canvas: HTMLCanvasElement) {\n\t\tthis.width = canvas.width;\n\t\tthis.height = canvas.height;\n\t\tthis._map = map;\n\t}\n\n\tget x(): number {\n\t\treturn this._x;\n\t}\n\n\tset x(value: number) {\n\t\tthis._x = value;\n\t\tthis._map.position.x = -this._x;\n\t}\n\n\tget y(): number {\n\t\treturn this._y;\n\t}\n\n\tset y(value: number) {\n\t\tthis._y = value;\n\t\tthis._map.position.y = -this._y;\n\t}\n\n\tget rightInnerBoundary(): number {\n\t\treturn this._x + this.width / 2 + this.width / 4;\n\t}\n\n\tget leftInnerBoundary(): number {\n\t\treturn this._x + this.width / 2 - this.width / 4;\n\t}\n\n\tget topInnerBoundary(): number {\n\t\treturn this._y + this.height / 2 - this.height / 4;\n\t}\n\n\tget bottomInnerBoundary(): number {\n\t\treturn this._y + this.height / 2 + this.height / 4;\n\t}\n\n\tfollow(sprite: DisplayObject): void {\n\t\tif (sprite.position.x < this.leftInnerBoundary) {\n\t\t\tthis.x = sprite.position.x - this.width / 4;\n\t\t}\n\n\t\tif (sprite.position.y < this.topInnerBoundary) {\n\t\t\tthis.y = sprite.position.y - this.height / 4;\n\t\t}\n\n\t\tif (sprite.position.x + sprite.width > this.rightInnerBoundary) {\n\t\t\tthis.x = sprite.position.x + sprite.width - (this.width / 4) * 3;\n\t\t}\n\n\t\tif (sprite.position.y + sprite.height > this.bottomInnerBoundary) {\n\t\t\tthis.y = sprite.position.y + sprite.height - (this.height / 4) * 3;\n\t\t}\n\n\t\tif (this.x < 0) {\n\t\t\tthis.x = 0;\n\t\t}\n\n\t\tif (this.y < 0) {\n\t\t\tthis.y = 0;\n\t\t}\n\n\t\tif (this.x + this.width > this._map.mapWidth) {\n\t\t\tthis.x = this._map.mapWidth - this.width;\n\t\t}\n\n\t\tif (this.y + this.height > this._map.mapHeight) {\n\t\t\tthis.y = this._map.mapHeight - this.height;\n\t\t}\n\t}\n\n\tcenterOver(sprite: DisplayObject): void {\n\t\tthis.x = sprite.position.x + sprite.halfWidth - this.width / 2;\n\t\tthis.y = sprite.position.y + sprite.halfHeight - this.height / 2;\n\n\t\tif (this.x < 0) {\n\t\t\tthis.x = 0;\n\t\t}\n\n\t\tif (this.y < 0) {\n\t\t\tthis.y = 0;\n\t\t}\n\n\t\tif (this.x + this.width > this._map.mapWidth) {\n\t\t\tthis.x = this._map.mapWidth - this.width;\n\t\t}\n\n\t\tif (this.y + this.height > this._map.mapHeight) {\n\t\t\tthis.y = this._map.mapHeight - this.height;\n\t\t}\n\t}\n}\n","import { DisplayObject } from \"DisplayObject\";\nimport { Point } from \"inks2d/math\";\n\nexport { Map } from \"./Map\";\nexport { MapCamera } from \"./MapCamera\";\n\nexport const getIndex = (\n\tpos: Point,\n\ttileWidth: number,\n\ttileHeight: number,\n\tmapWidthInTiles: number,\n): number => {\n\tconst index = new Point();\n\n\tindex.x = Math.floor(pos.x / tileWidth);\n\tindex.y = Math.floor(pos.y / tileHeight);\n\n\treturn index.x + index.y * mapWidthInTiles;\n};\n\nexport const getPoints = (\n\tsprite: DisplayObject,\n\tglobal: boolean = false,\n): Record<string, Point> => {\n\tconst bounds = global ? sprite.localBounds() : sprite.globalBounds();\n\t/**\n\t * The bottom and left corner points are 1 pixel\n\t * less than the sprite’s width and height so that\n\t * the points remain inside the sprite, and not\n\t * outside it;\n\t */\n\treturn {\n\t\ttopLeft: new Point(bounds.x, bounds.y),\n\t\ttopRight: new Point(bounds.x + bounds.width - 1, bounds.y),\n\t\tbottomLeft: new Point(bounds.x, bounds.y + bounds.height - 1),\n\t\tbottomRight: new Point(\n\t\t\tbounds.x + bounds.width - 1,\n\t\t\tbounds.y + bounds.height - 1,\n\t\t),\n\t};\n};\n\nexport const hitTestTile = (\n\tsprite: DisplayObject,\n\tmapArray: number[],\n\tgidToCheck: number,\n\tpointsToCheck: \"every\" | \"some\" | \"center\" = \"some\",\n\ttileWidth: number,\n\ttileHeight: number,\n\tmapWidthInTiles: number,\n): Record<string, number | boolean> => {\n\tconst collision: Record<string, number | boolean> = {};\n\tlet collisionPoints: Record<string, Point> = getPoints(sprite);\n\n\tconst checkPoints = (key: string): boolean => {\n\t\tconst point = collisionPoints[key];\n\t\tcollision.index = getIndex(point, tileWidth, tileHeight, mapWidthInTiles);\n\n\t\tcollision.gid = mapArray[collision.index];\n\n\t\tif (collision.gid === gidToCheck) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t};\n\n\tconst methodToExec = pointsToCheck === \"center\" ? \"some\" : pointsToCheck;\n\n\tif (pointsToCheck === \"center\") {\n\t\tconst point = {\n\t\t\tcenter: new Point(sprite.localCenterX, sprite.localCenterY),\n\t\t};\n\t\tcollisionPoints = point;\n\t}\n\n\tcollision.hasContact =\n\t\tObject.keys(collisionPoints)[methodToExec](checkPoints);\n\n\treturn collision;\n};\n"]}